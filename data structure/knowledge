ch6.tree:
1.storage structure of tree:
	1.双亲表示法：
		1.data|parent
		2.data|parent|rightsib
	2.孩子表示法：
		1.data|fristchild->child|next//孩子表示法
		  0 A|-> 1|-> 2|^
		  1 B|-> 3|^
		  2 C|-> 4|-> 5|^
		2.data|parent|fristchild->child|next//孩子双亲表示法
		  0 A|-1|-> 1|-> 2|^
		  1 B| 0|-> 3|^
		  2 C| 0|-> 4|-> 5|^
	3.孩子兄弟表示法：
		data|firstchild|rightsib//可将一棵复杂的树变成二叉树

2.special binary tree：
	1.斜树
	2.满二叉树
	3.完全二叉树

3.traverse of a tree:
	1.preorder
	2.inorder
	3.postorder

	given the preoder and inorder|the postorder and inorder,the tree can be solved;
	given the preoder and postorder,the tree cannot be solved;

4.对二叉树以某种次序遍历使其变为线索二叉树的过程叫做线索化。

5.图的表示：
	1.邻接矩阵 			顶点数组(n)+边矩阵(n*n) O(n+n*n+e)
	2.（逆）邻接表   	顶点数组(data|firstedge)->边链表（adjvex|next) O(n+e) 同一条边有两个节点表示
	3.十字链表(有向图邻接表优化)	顶点数组（data|firstin|firstout)->边链表（tailvex|headvex|headlink|taillink)实质是把有向图的邻接表和逆邻接表结合到一起 O(n+e) 相比于邻接表，可以同时求得入度与出度
	4.临接多重表(无向图邻接表优化) 顶点数组(data|firstedge)->边链表(ivex|ilink|jvex|jlink) 同一条边只需一个节点表示
	5.边集数组 顶点数组（data|num）+边数组(beginnum|endnum|weight)  用于克鲁斯卡尔算法(kruskal)

6.深度优先遍历（depth_first_traverse)&广度优先遍历（Breadth_first_traverse)

7.最小生成树
	1.普里姆算法(prim)  “加点法” O(n*n) 针对点，适合稠密图 邻接矩阵
		1.图的所有顶点集合为V；初始令集合u={s},v=V−u;
		2.在两个集合u,v能够组成的边中，选择一条代价最小的边(u0,v0)，加入到最小生成树中，并把v0并入到集合u中。
		3.重复上述步骤，直到最小生成树有n-1条边或者n个顶点为止。
	2.克鲁斯卡尔算法(kruskal)  “加边法” O(e*loge) 针对边，适合稀疏图 边集数组
		1. 把图中的所有边按代价从小到大排序； 
		2. 把图中的n个顶点看成独立的n棵树组成的森林； 
		3. 按权值从小到大选择边，所选的边连接的两个顶点ui,vi,应属于两颗不同的树，则成为最小生成树的一条边，并将这两颗树合并作为一颗树。 
		4. 重复(3),直到所有顶点都在一颗树内或者有n-1条边为止。

8.最短路径
	1.Dijkstra算法  单源最短路径算法 O(n*n)
	2.Floyd算法  任意两点间的最短路径 O(n*n*n)

9.有向无环图
	1.拓扑排序 AOV网 Activity on Vertex Network 顶点表示活动，弧表示活动之间的关系 O(n+e) 解决工程能否顺利进行
	2.关键路径 AOE网 Activity on Edge Network 顶点表示事件，弧表示活动，弧上的权值表示活动的持续时间  O(n+e)  在拓扑排序的基础上解决最短时间内完成工程的问题

10.查找(静态查找/只有查找、动态查找/查找+插入或删除）
	1.顺序表查找(无序、设置一个哨兵减小运算量) o(n)
	2.有序表查找（三种方法本质上是分割点不同）
		1.折半查找 o(logn) mid=(high+low)/2=low+1/2*(high-low)//加法+除法
		2.插值查找 mid=low+((key-a[low])/(a[high]-a[low]))*(high-low)//四则运算
		3.裴波那契查找 mid=low+F[k-1]-1//只有加减法运算（对于海量数据可能效率更高）
	3.线性索引查找
		1.稠密索引
		2.分块索引：块间有序，块内不要求有序，最大关键码|块长|块首指针 首先在块间折半、插值、裴波那契查找，然后在块内顺序表查找（无序）o(n^(1/2))
		3.倒排索引：搜索引擎常用
	4.二叉排序树（又称为二叉查找树）（插入删除效率不错，查找效率也比较高，对动态查找表而言）binary sort tree
		性质：
			1.左子树不空则左子树上所有节点的值均小于根结构上的值
			2.右子树不空则右子树上所有节点的值均大于根结构上的值
			3.左右子树也分别为二叉排序树
	5.平衡二叉树(AVL树) 每一个节点的左子树和右子树的深度差至多为1
		在构建二叉排序树的过程中，调整最小不平衡子树中各节点的链接关系，进行相应的旋转，使之称为新的平衡子树。查找和插入删除均为o(logn)
	6.多路查找树：2-3树，2-3-4树，
		B树（一种平衡的多路查找树，2-3树，2-3-4树是B树的特例）：结点的最大孩子数目称为B树的阶，针对内存与外存之间的存取而专门设计。
		B+树（n棵子树的结点中包含有n个关键字）应文件系统所需而出的一种B树的变形树。
	7.散列表查找（哈希表）
		散列函数（哈希函数）使得一个关键字key对应一个存储位置f(key)：计算简单&散列地址分布均匀
		1.直接定址法 f(key)=a*key+b
		2.数字分析法 (抽取关键词的一部分作为关键字，如取电话号码后四位)
		3.平方取中法（关键字平方后取其中几位作为散列地址）
		4.折叠法：987|654|321|0->987+654+321+0=1962->962
		5.除留余数法：
		6.随机数法
	8.处理散列冲突的办法：
		1.开放定址法（线性探测法，二次探测法，随机探测法）
		2.再散列函数法（准备多个散列函数）
		3.链地址法（冲突的位置加一个链表）
		4.公共溢出区法
11.排序
	1.排序的稳定性
	2.内排序和外排序，内排序主要分为插入排序、交换排序、选择排序、归并排序
	3.衡量性能标准：时间性能、辅助空间、算法的复杂性
12.排序方式：
	简单算法：
	1.冒泡排序 O(n*n) 稳定
	2.简单选择排序 O(n*n) 稳定
	3.直接插入排序 O(n*n) 简单排序中性能最好的 稳定

	改进算法：
	4.希尔排序 O(n^(3/2)) 增量序列的最后一个增量值必须为1，基本有序（直接插入排序的升级）不稳定
	5.堆排序 O(n*logn) 记录的比较和交换是跳跃式进行，因此是一种不稳定的排序方式 heap sort（简单选择排序的升级）不稳定
	6.归并排序 O(n*logn) merge sort 空间复杂度：O(n+logn)=O(n) 比较占用内存，但效率高且稳定 采用递归方式会造成时间和空间损耗，使用非递归的迭代方式可以在一定程度上减小空间和时间复杂度
	7.快速排序 最差O(n*n),最好O(n*logn) 空间复杂度：O(logn)~O(n)冒泡排序的升级 不稳定
